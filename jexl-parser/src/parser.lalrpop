use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::ast::{Expression, OpCode, StdFunction, NumericValue, StringValue, ArrayValue, DateTimeValue, DateLikeValue, TimeLikeValue, DurationValue};

grammar;

pub Expression: Box<Expression> = Expr00;

Expr00: Box<Expression> = {
    <left: Expression> <operation: LogicalOp> <right: Expr10> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr10,
};

Expr10: Box<Expression> = {
    <left: Expr10> <operation: ComparisonOp> <right: Expr20> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr20,
};

Expr20: Box<Expression> = {
    <left: Expr20> <operation: Op30> <right: Expr30> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr30,
};

Expr30: Box<Expression> = {
    <left: Expr30> <operation: Op40> <right: Expr40> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr40,
};

Expr40: Box<Expression> = {
    <left: Expr40> <operation: Op50> <right: Expr50> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr50,
};

Expr50: Box<Expression> = {
    <left: Expr50> "?" <truthy: Expr60> ":" <falsy: Expr70> => Box::new(Expression::Conditional {left, truthy, falsy}),
    Expr60,
}

Expr60: Box<Expression> = {
    <subject: Expr60> "|" <name: Identifier> <args: FnArgs> => Box::new(Expression::CustomTransform{name, subject, args}),
    Expr70
};

Expr70: Box<Expression> = {
    "not " <expr: Expr70>  => Box::new(Expression::NegationOperation{expr}),
    "!" <expr: Expr70>  => Box::new(Expression::NegationOperation{expr}),
    Expr80
};

/// Expression for dereferencing.
/// Used for dereferencing object literals, array literals, and the context
/// There are two types of operations here:
/// - Either a `dot` operation, taking an expression on the left hand side, and an identifier on the right hand side (a string without the quotations)
/// - Or an `index` operation, taking an expression on the left hand side, and another expression inside square ("[]") brackets.
///
/// # Examples:
/// 
/// Assume our context is the following
/// ```
///{
///  "foo":
///  {
///     "bar": [{"baz": 1}, {"bobo": [13, 12]}]
//   }
// }
/// ```
///
/// `foo.bar == [{"baz": 1}, {"bobo": [13, 12]]`
/// `foo.bar[0] == {"baz": 1}`
/// `foo.bar[1].bobo[0] == 13`
/// `[1, 2, 3][1] == 2`
Expr80: Box<Expression> = {
    // <array value>.any()
    <subject: Expr80> "." "any" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncAny(ArrayValue{array: subject}))),

    // <array value>.all()
    <subject: Expr80> "." "all" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncAll(ArrayValue{array: subject}))),

    // <array value>.max()
    <subject: Expr80> "." "max" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncMax(ArrayValue{array: subject}))),

    // <array value>.min()
    <subject: Expr80> "." "min" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncMin(ArrayValue{array: subject}))),

    // <array value>.sum()
    <subject: Expr80> "." "sum" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncSum(ArrayValue{array: subject}))),

    // <any value>.len()
    <subject: Expr80> "." "len" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncLen(subject))),

    // <any value>.is_empty()
    <subject: Expr80> "." "is_empty" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsEmpty(subject))),

    // <string value>.capitalise()
    <subject: Expr80> "." "capitalise" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncCapitalise(StringValue{value: subject}))),

    // <string value>.to_upper_case()
    <subject: Expr80> "." "to_upper_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncUpperCase(StringValue{value: subject}))),

    // <string value>.to_lower_case()
    <subject: Expr80> "." "to_lower_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncLowerCase(StringValue{value: subject}))),

    // <string value>.to_title_case()
    <subject: Expr80> "." "to_title_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncTitleCase(StringValue{value: subject}))),

    // <string value>.to_kebab_case()
    <subject: Expr80> "." "to_kebab_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncKebabCase(StringValue{value: subject}))),

    // <string value>.to_snake_case()
    <subject: Expr80> "." "to_snake_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncSnakeCase(StringValue{value: subject}))),

    // <string value>.swap_case()
    <subject: Expr80> "." "swap_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncSwapCase(StringValue{value: subject}))),

    // <string value>.to_train_case()
    <subject: Expr80> "." "to_train_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncTrainCase(StringValue{value: subject}))),

    // <string value>.to_pascal_case()
    <subject: Expr80> "." "to_pascal_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncPascalCase(StringValue{value: subject}))),

    // <string value>.to_shouty_kebab_case()
    <subject: Expr80> "." "to_shouty_kebab_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncShoutyKebabCase(StringValue{value: subject}))),

    // <string value>.to_shouty_snake_cse()
    <subject: Expr80> "." "to_shouty_snake_cse" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncShoutySnakeCase(StringValue{value: subject}))),

    // <string value>.md5()
    <subject: Expr80> "." "md5" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncMD5(StringValue{value: subject}))),

    // <string value>.sha256()
    <subject: Expr80> "." "sha256" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncSHA256(StringValue{value: subject}))),

    // <string value>.is_decimal()
    <subject: Expr80> "." "is_decimal" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsDecimal(StringValue{value: subject}))),

    // <string value>.is_alpha_num()
    <subject: Expr80> "." "is_alpha_num" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsAlphaNum(StringValue{value: subject}))),

    // <string value>.is_alpha()
    <subject: Expr80> "." "is_alpha" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsAlpha(StringValue{value: subject}))),

    // <string value>.is_digit()
    <subject: Expr80> "." "is_digit" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsDigit(StringValue{value: subject}))),

    // <string value>.is_numeric()
    <subject: Expr80> "." "is_numeric" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsNumeric(StringValue{value: subject}))),

    // <string value>.is_space()
    <subject: Expr80> "." "is_space" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsSpace(StringValue{value: subject}))),

    // <string value>.is_identifier()
    <subject: Expr80> "." "is_identifier" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsIdentifier(StringValue{value: subject}))),

    // <string value>.is_lower_case()
    <subject: Expr80> "." "is_lower_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsLowerCase(StringValue{value: subject}))),

    // <string value>.is_upper_case()
    <subject: Expr80> "." "is_upper_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsUpperCase(StringValue{value: subject}))),

    // <string value>.is_title_case()
    <subject: Expr80> "." "is_title_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsTitleCase(StringValue{value: subject}))),

    // <string value>.is_snake_case()
    <subject: Expr80> "." "is_snake_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsSnakeCase(StringValue{value: subject}))),

    // <string value>.is_train_case()
    <subject: Expr80> "." "is_train_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsTrainCase(StringValue{value: subject}))),

    // <string value>.is_pascal_case()
    <subject: Expr80> "." "is_pascal_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsPascalCase(StringValue{value: subject}))),

    // <string value>.is_shouty_kebab_case()
    <subject: Expr80> "." "is_shouty_kebab_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsShoutyKebabCase(StringValue{value: subject}))),

    // <string value>.is_shouty_snake_case()
    <subject: Expr80> "." "is_shouty_snake_case" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsShoutySnakeCase(StringValue{value: subject}))),

    // <string value>.strip()
    <subject: Expr80> "." "strip" "(" <with: Expression?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncStrip{subject: StringValue{value: subject}, with: with.map(|s| StringValue{value: s})})),

    // <string value>.lstrip()
    <subject: Expr80> "." "lstrip" "(" <with: Expression?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncLStrip{subject: StringValue{value: subject}, with: with.map(|s| StringValue{value: s})})),

    // <string value>.rstrip()
    <subject: Expr80> "." "rstrip" "(" <with: Expression?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRStrip{subject: StringValue{value: subject}, with: with.map(|s| StringValue{value: s})})),

    // <string value>.ends_with()
    <subject: Expr80> "." "ends_with" "(" <with: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncEndsWith{subject: StringValue{value: subject}, with: StringValue{value: with}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.starts_with()
    <subject: Expr80> "." "starts_with" "(" <with: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncStartsWith{subject: StringValue{value: subject}, with: StringValue{value: with}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.split()
    <subject: Expr80> "." "split" "(" <with: Expression> <num_splits:("," "num_splits" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncSplit{subject: StringValue{value: subject}, with: StringValue{value: with}, num_splits: num_splits.map(|s| NumericValue{value: s})})),

    // <string value>.words()
    <subject: Expr80> "." "split" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncWords(StringValue{value: subject}))),

    // <string value>.index()
    <subject: Expr80> "." "index" "(" <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIndex{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.rindex()
    <subject: Expr80> "." "rindex" "(" <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRIndex{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.find()
    <subject: Expr80> "." "find" "(" <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncFind{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.rfind()
    <subject: Expr80> "." "rfind" "(" <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRFind{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <numeric value>.hex()
    <subject: Expr80> "." "hex" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncHex(NumericValue{value: subject}))),

    // <numeric value>.oct()
    <subject: Expr80> "." "oct" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncOct(NumericValue{value: subject}))),

    // <numeric value>.abs()
    <subject: Expr80> "." "abs" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncAbs(NumericValue{value: subject}))),

    // <numeric value>.round()
    <subject: Expr80> "." "round" "(" <num_digits: Expression?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRound(NumericValue{value: subject}, num_digits.map(|n| NumericValue{value: n})))),

    // <string value>.to_local_datetime()
    <subject: Expr80> "." "to_local_datetime" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncParseLocalDateTime(StringValue{value: subject}))),

    // <string or numeric value>.to_utc_datetime()
    <subject: Expr80> "." "to_utc_datetime" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncParseUtcDateTime(StringValue{value: subject}))),
    
    // <datetime value>.get_date()
    <subject: Expr80> "." "get_date" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDateFromDateTime(DateTimeValue{value: subject}))),

    // <datetime value>.get_time()
    <subject: Expr80> "." "get_time" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetTimeFromDateTime(DateTimeValue{value: subject}))),

    // <datetime value>.get_timestamp()
    <subject: Expr80> "." "get_timestamp" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetTimestampFromDateTime(DateTimeValue{value: subject}))),

    // <datetime value>.get_timestamp_millis()
    <subject: Expr80> "." "get_timestamp_millis" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetTimestampMillisFromDateTime(DateTimeValue{value: subject}))),

    // <datelike value>.get_year()
    <subject: Expr80> "." "get_year" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetYearFromDate(DateLikeValue{value: subject}))),

    // <datelike value>.get_month()
    <subject: Expr80> "." "get_month" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMonthFromDate(DateLikeValue{value: subject}))),

    // <datelike value>.get_day_of_month()
    <subject: Expr80> "." "get_day_of_month" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDayOfMonthFromDate(DateLikeValue{value: subject}))),

    // <datelike value>.get_day_of_year()
    <subject: Expr80> "." "get_day_of_year" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDayOfYearFromDate(DateLikeValue{value: subject}))),

    // <datelike value>.get_day_of_week()
    <subject: Expr80> "." "get_day_of_week" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDayOfWeekFromDate(DateLikeValue{value: subject}))),

    // <timelike value>.get_hour()
    <subject: Expr80> "." "get_hour" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetHourFromTime(TimeLikeValue{value: subject}))),

    // <timelike value>/get_minute()
    <subject: Expr80> "." "get_minute" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMinuteFromTime(TimeLikeValue{value: subject}))),

    // <timelike value>.get_second()
    <subject: Expr80> "." "get_second" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetSecondFromTime(TimeLikeValue{value: subject}))),

    // <timelike value>.get_millisecond()
    <subject: Expr80> "." "get_millisecond" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMillisecondFromTime(TimeLikeValue{value: subject}))),

    // <duration value>.get_weeks()
    <subject: Expr80> "." "get_weeks" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetWeeksFromDuration(DurationValue{value: subject}))),

    // <duration value>.get_days()
    <subject: Expr80> "." "get_days" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDaysFromDuration(DurationValue{value: subject}))),

    // <duration value>.get_hours()
    <subject: Expr80> "." "get_hours" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetHoursFromDuration(DurationValue{value: subject}))),

    // <duration value>.get_minutes()
    <subject: Expr80> "." "get_minutes" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMinutesFromDuration(DurationValue{value: subject}))),

    // <duration value>.get_seconds()
    <subject: Expr80> "." "get_seconds" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetSecondsFromDuration(DurationValue{value: subject}))),

    // <duration value>.get_milliseconds()
    <subject: Expr80> "." "get_milliseconds" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMillisecondsFromDuration(DurationValue{value: subject}))),

    // get_microseconds(<duration value>)
    <subject: Expr80> "." "get_microseconds" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMicrosecondsFromDuration(DurationValue{value: subject}))),    

    <subject: Expr80> "." <name: Identifier> <args: FnArgs> => Box::new(Expression::CustomTransform{name, subject, args}),

    <subject: Expr80> <index: Index> => Box::new(Expression::IndexOperation{subject, index}),

    // dot operation with default value
    <subject: Expr80> "." "get" "(" <ident: Identifier> "," <default_value: Expression> ")"  => Box::new(Expression::DotOperation{subject, ident, default_value: Some(default_value)}),

    // TODO: check whether String is identifier string
    <subject: Expr80> "." "get" "(" <ident: String> "," <default_value: Expression> ")"  => Box::new(Expression::DotOperation{subject, ident, default_value: Some(default_value)}),

    // dot operation
    <subject: Expr80> "." <ident: Identifier>  => Box::new(Expression::DotOperation{subject, ident, default_value: None}),

    Expr90
};

Expr90: Box<Expression> = {
    Number => Box::new(Expression::Number(<>)),
    Boolean => Box::new(Expression::Boolean(<>)),
    String => Box::new(Expression::String(<>)),
    Array => Box::new(Expression::Array(<>)),
    Object => Box::new(Expression::Object(<>)),
    Identifier => Box::new(Expression::Identifier(<>)),

    // duration with no args
    "duration" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncDuration{days: None, hours: None, minutes: None, seconds: None, milliseconds: None, microseconds: None, weeks: None})),

    // duration with positional args
    "duration" "(" <args: PositionalArgs> ")" =>? {
        let mut days = None;
        let mut hours = None;
        let mut minutes = None;
        let mut seconds = None;
        let mut milliseconds = None;
        let mut microseconds = None;
        let mut weeks = None;

        for (name, arg) in args.into_iter() {
            let value = Some(NumericValue{value: arg});
            match name.as_str() {
                "days" => {
                    days = value;
                },
                "hours" => {
                    hours = value;
                },
                "minutes" => {
                    minutes = value;
                },
                "seconds" => {
                    seconds = value;
                },
                "milliseconds" => {
                    milliseconds = value;
                },
                "microseconds" => {
                    microseconds = value;
                },
                "weeks" => {
                    weeks = value;
                },

                _ => {
                    return Err(ParseError::User{error: "Unknown argument to duration"});
                }
            }
        }

        let duration_fn = StdFunction::FuncDuration{days, hours, minutes, seconds, milliseconds, microseconds, weeks};

        Ok(Box::new(Expression::StdFunction(duration_fn)))
    },

    // local_now()
    "local_now" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncLocalNow())),

    // utc_now()
    "utc_now" "(" ")" => Box::new(Expression::StdFunction(StdFunction::FuncUtcNow())),

    // <array value>.any()
    "any" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncAny(ArrayValue{array: subject}))),

    // <array value>.all()
    "all" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncAll(ArrayValue{array: subject}))),

    // <array value>.max()
    "max" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncMax(ArrayValue{array: subject}))),

    // <array value>.min()
    "min" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncMin(ArrayValue{array: subject}))),

    // <array value>.sum()
    "sum" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncSum(ArrayValue{array: subject}))),

    // <any value>.len()
    "len" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncLen(subject))),

    // <any value>.is_empty()
    "is_empty" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsEmpty(subject))),

    // <string value>.capitalise()
    "capitalise" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncCapitalise(StringValue{value: subject}))),

    // <string value>.to_upper_case()
    "to_upper_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncUpperCase(StringValue{value: subject}))),

    // <string value>.to_lower_case()
    "to_lower_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncLowerCase(StringValue{value: subject}))),

    // <string value>.to_title_case()
    "to_title_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncTitleCase(StringValue{value: subject}))),

    // <string value>.to_kebab_case()
    "to_kebab_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncKebabCase(StringValue{value: subject}))),

    // <string value>.to_snake_case()
    "to_snake_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncSnakeCase(StringValue{value: subject}))),

    // <string value>.swap_case()
    "swap_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncSwapCase(StringValue{value: subject}))),

    // <string value>.to_train_case()
    "to_train_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncTrainCase(StringValue{value: subject}))),

    // <string value>.to_pascal_case()
    "to_pascal_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncPascalCase(StringValue{value: subject}))),

    // <string value>.to_shouty_kebab_case()
    "to_shouty_kebab_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncShoutyKebabCase(StringValue{value: subject}))),

    // <string value>.to_shouty_snake_cse()
    "to_shouty_snake_cse" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncShoutySnakeCase(StringValue{value: subject}))),

    // <string value>.md5()
    "md5" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncMD5(StringValue{value: subject}))),

    // <string value>.sha256()
    "sha256" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncSHA256(StringValue{value: subject}))),

    // <string value>.is_decimal()
    "is_decimal" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsDecimal(StringValue{value: subject}))),

    // <string value>.is_alpha_num()
    "is_alpha_num" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsAlphaNum(StringValue{value: subject}))),

    // <string value>.is_alpha()
    "is_alpha" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsAlpha(StringValue{value: subject}))),

    // <string value>.is_digit()
    "is_digit" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsDigit(StringValue{value: subject}))),

    // <string value>.is_numeric()
    "is_numeric" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsNumeric(StringValue{value: subject}))),

    // <string value>.is_space()
    "is_space" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsSpace(StringValue{value: subject}))),

    // <string value>.is_identifier()
    "is_identifier" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsIdentifier(StringValue{value: subject}))),

    // <string value>.is_lower_case()
    "is_lower_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsLowerCase(StringValue{value: subject}))),

    // <string value>.is_upper_case()
    "is_upper_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsUpperCase(StringValue{value: subject}))),

    // <string value>.is_title_case()
    "is_title_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsTitleCase(StringValue{value: subject}))),

    // <string value>.is_snake_case()
    "is_snake_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsSnakeCase(StringValue{value: subject}))),

    // <string value>.is_train_case()
    "is_train_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsTrainCase(StringValue{value: subject}))),

    // <string value>.is_pascal_case()
    "is_pascal_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsPascalCase(StringValue{value: subject}))),

    // <string value>.is_shouty_kebab_case()
    "is_shouty_kebab_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsShoutyKebabCase(StringValue{value: subject}))),

    // <string value>.is_shouty_snake_case()
    "is_shouty_snake_case" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIsShoutySnakeCase(StringValue{value: subject}))),

    // <string value>.strip()
    "strip" "(" <subject: Expression> <with: ("," <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncStrip{subject: StringValue{value: subject}, with: with.map(|s| StringValue{value: s})})),

    // <string value>.lstrip()
    "lstrip" "(" <subject: Expression> <with: ("," <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncLStrip{subject: StringValue{value: subject}, with: with.map(|s| StringValue{value: s})})),

    // <string value>.rstrip()
    "rstrip" "(" <subject: Expression> <with: ("," <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRStrip{subject: StringValue{value: subject}, with: with.map(|s| StringValue{value: s})})),

    // <string value>.ends_with()
    "ends_with" "(" <subject: Expression> "," <with: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncEndsWith{subject: StringValue{value: subject}, with: StringValue{value: with}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.starts_with()
    "starts_with" "(" <subject: Expression> "," <with: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncStartsWith{subject: StringValue{value: subject}, with: StringValue{value: with}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.split()
    "split" "(" <subject: Expression> "," <with: Expression> <num_splits:("," "num_splits" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncSplit{subject: StringValue{value: subject}, with: StringValue{value: with}, num_splits: num_splits.map(|s| NumericValue{value: s})})),

    // <string value>.words()
    "words" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncWords(StringValue{value: subject}))),

    // <string value>.index()
    "index" "(" <subject: Expression> "," <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncIndex{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.rindex()
    "rindex" "(" <subject: Expression> "," <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRIndex{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // <string value>.find()
    "find" "(" <subject: Expression> "," <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncFind{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // rfind(<string value>)
    "rfind" "(" <subject: Expression> "," <search: Expression> <start:("," "start" "=" <Expression>)?> <end:("," "end" "=" <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRFind{subject: StringValue{value: subject}, search: StringValue{value: search}, start: start.map(|s| NumericValue{value: s}), end: end.map(|s| NumericValue{value: s})})),

    // hex(<numeric value>)
    "hex" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncHex(NumericValue{value: subject}))),

    // oct(<numeric value>)
    "oct" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncOct(NumericValue{value: subject}))),

    // abs(<numeric value>)
    "abs" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncAbs(NumericValue{value: subject}))),

    // round(<numeric value>)
    "round" "(" <subject: Expression> <num_digits: ("," <Expression>)?> ")" => Box::new(Expression::StdFunction(StdFunction::FuncRound(NumericValue{value: subject}, num_digits.map(|n| NumericValue{value: n})))),

    // parse_local_datetime(<string value>)
    "parse_local_datetime" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncParseLocalDateTime(StringValue{value: subject}))),

    // parse_utc_datetime(<string value>)
    "parse_utc_datetime" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncParseUtcDateTime(StringValue{value: subject}))),

    // local_datetime.from_timestamp_secs(<numeric value>)
    "local_datetime" "." "from_timestamp_secs" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncLocalDateTimeFromTimestampSecs(NumericValue{value: subject}))),

    // utc_datetime.from_timestamp_secs(<numeric value>)
    "utc_datetime" "." "from_timestamp_secs" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncUtcDateTimeFromTimestampSecs(NumericValue{value: subject}))),

    // local_datetime.from_timestamp_millis(<numeric value>)
    "local_datetime" "." "from_timestamp_millis" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncLocalDateTimeFromTimestampMillis(NumericValue{value: subject}))),

    // utc_datetime.from_timestamp_millis(<numeric value>)
    "utc_datetime" "." "from_timestamp_millis" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncUtcDateTimeFromTimestampMillis(NumericValue{value: subject}))),

    // local_datetime(y, m, d, h, mm, ss, ms, us)
    "local_datetime" "(" <args: PositionalArgs> ")" =>? {
        let mut y = None;
        let mut m = None;
        let mut d = None;
        let mut h = None;
        let mut mm = None;
        let mut ss = None;
        let mut ms = None;
        let mut us = None;

        for (name, arg) in args.into_iter() {
         let value = Some(NumericValue{value: arg});
         match name.as_str() {
             "y" => {
                 y = value;
             },
             "m" => {
                 m = value;
             },
             "d" => {
                 d = value;
             },
             "h" => {
                 h = value;
             },
             "mm" => {
                 mm = value;
             },
             "ss" => {
                 ss = value;
             },
             "ms" => {
                 ms = value;
             },
             "us" => {
                  us = value;
              },

             _ => {
                 return Err(ParseError::User{error: "Unknown argument to local_datetime"});
             }
         }
        }

        let datetime_fn = StdFunction::FuncLocalDateTime{y, m, d, h, mm, ss, ms, us};

        Ok(Box::new(Expression::StdFunction(datetime_fn)))
    },

    // utc_datetime(y, m, d, h, mm, ss, ms, us)
    "utc_datetime" "(" <args: PositionalArgs> ")" =>? {
        let mut y = None;
        let mut m = None;
        let mut d = None;
        let mut h = None;
        let mut mm = None;
        let mut ss = None;
        let mut ms = None;
        let mut us = None;

        for (name, arg) in args.into_iter() {
         let value = Some(NumericValue{value: arg});
         match name.as_str() {
             "y" => {
                 y = value;
             },
             "m" => {
                 m = value;
             },
             "d" => {
                 d = value;
             },
             "h" => {
                 h = value;
             },
             "mm" => {
                 mm = value;
             },
             "ss" => {
                 ss = value;
             },
             "ms" => {
                 ms = value;
             },
             "us" => {
                  us = value;
              },

             _ => {
                 return Err(ParseError::User{error: "Unknown argument to utc_datetime"});
             }
         }
        }

        let datetime_fn = StdFunction::FuncUtcDateTime{y, m, d, h, mm, ss, ms, us};

        Ok(Box::new(Expression::StdFunction(datetime_fn)))
    },

    // date(y, m, d)
    "date" "(" <args: PositionalArgs> ")" =>? {
        let mut y = None;
        let mut m = None;
        let mut d = None;

        for (name, arg) in args.into_iter() {
         let value = Some(NumericValue{value: arg});
         match name.as_str() {
             "y" => {
                 y = value;
             },
             "m" => {
                 m = value;
             },
             "d" => {
                 d = value;
             },

             _ => {
                 return Err(ParseError::User{error: "Unknown argument to date"});
             }
         }
        }

        let date_fn = StdFunction::FuncDate{y, m, d};

        Ok(Box::new(Expression::StdFunction(date_fn)))
    },

    // time(h, mm, ss, ms, us)
    "time" "(" <args: PositionalArgs> ")" =>? {
        let mut h = None;
        let mut mm = None;
        let mut ss = None;
        let mut ms = None;
        let mut us = None;

        for (name, arg) in args.into_iter() {
         let value = Some(NumericValue{value: arg});
         match name.as_str() {
             "h" => {
                 h = value;
             },
             "mm" => {
                 mm = value;
             },
             "ss" => {
                 ss = value;
             },
             "ms" => {
                 ms = value;
             },
             "us" => {
                  us = value;
              },

             _ => {
                 return Err(ParseError::User{error: "Unknown argument to time"});
             }
         }
        }

        let time_fn = StdFunction::FuncTime{h, mm, ss, ms, us};

        Ok(Box::new(Expression::StdFunction(time_fn)))
    },

    // parse_duration(<string value>)
    "parse_duration" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncParseDuration(StringValue{value: subject}))),

    // sem_version(<string value>)
    "sem_version" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncSemVersion(StringValue{value: subject}))),

    // get_date(<datetime value>)
    "get_date" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDateFromDateTime(DateTimeValue{value: subject}))),

    // get_time(<datetime value>)
    "get_time" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetTimeFromDateTime(DateTimeValue{value: subject}))),

    // get_timestamp(<datetime value>)
    "get_timestamp" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetTimestampFromDateTime(DateTimeValue{value: subject}))),

    // get_timestamp_millis(<datetime value>)
    "get_timestamp_millis" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetTimestampMillisFromDateTime(DateTimeValue{value: subject}))),

    // get_year(<datelike value>)
    "get_year" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetYearFromDate(DateLikeValue{value: subject}))),

    // get_month(<datelike value>)
    "get_month" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMonthFromDate(DateLikeValue{value: subject}))),

    // get_day_of_month(<datelike value>)
    "get_day_of_month" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDayOfMonthFromDate(DateLikeValue{value: subject}))),

    // get_day_of_year(<datelike value>)
    "get_day_of_year" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDayOfYearFromDate(DateLikeValue{value: subject}))),

    // get_day_of_week(<datelike value>)
    "get_day_of_week" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDayOfWeekFromDate(DateLikeValue{value: subject}))),

    // get_hour(<timelike value>)
    "get_hour" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetHourFromTime(TimeLikeValue{value: subject}))),

    // get_minute(<timelike value>)
    "get_minute" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMinuteFromTime(TimeLikeValue{value: subject}))),

    // get_second(<timelike value>)
    "get_second" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetSecondFromTime(TimeLikeValue{value: subject}))),

    // get_millisecond(<timelike value>)
    "get_millisecond" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMillisecondFromTime(TimeLikeValue{value: subject}))),

    // get_weeks(<duration value>)
    "get_weeks" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetWeeksFromDuration(DurationValue{value: subject}))),

    // get_days(<duration value>)
    "get_days" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetDaysFromDuration(DurationValue{value: subject}))),

    // get_hours(<duration value>)
    "get_hours" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetHoursFromDuration(DurationValue{value: subject}))),

    // get_minutes(<duration value>)
    "get_minutes" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMinutesFromDuration(DurationValue{value: subject}))),

    // get_seconds(<duration value>)
    "get_seconds" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetSecondsFromDuration(DurationValue{value: subject}))),

    // get_milliseconds(<duration value>)
    "get_milliseconds" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMillisecondsFromDuration(DurationValue{value: subject}))),

    // get_microseconds(<duration value>)
    "get_microseconds" "(" <subject: Expression> ")" => Box::new(Expression::StdFunction(StdFunction::FuncGetMicrosecondsFromDuration(DurationValue{value: subject}))),

    <name: Identifier> <args: FnArgs> => Box::new(Expression::CustomFunction{name, args}),

    "(" <Expression> ")",
};

FnArgs: Option<Vec<Box<Expression>>> = {
    "(" <args: CommaSeparatedArgs>  ")" => Some(args),
    "(" ")" => None,
};

CommaSeparatedArgs: Vec<Box<Expression>> = {
    <arg_1: Expression> <mut other_args:("," <Expression>)*> => {
        let mut v = Vec::<Box<Expression>>::new();
        v.push(arg_1);
        v.append(&mut other_args);

        v
    }
};

PositionalArgs: Vec<(String, Box<Expression>)> = {
    <mut list: PositionalArgs> "," <name: Identifier> "=" <arg: Expression> => {
        list.push((name, arg));
        list
    },
    <name: Identifier> "=" <arg: Expression> => vec![(name, arg)]
};

LogicalOp: OpCode = {
    " and " => OpCode::And,
    "&&" => OpCode::And,

    " or " => OpCode::And,
    "||" => OpCode::Or,
};

ComparisonOp: OpCode = {
    " eq " => OpCode::Equal,
    "==" => OpCode::Equal,

    " ne " => OpCode::NotEqual,
    "!=" => OpCode::NotEqual,

    " ge " => OpCode::GreaterEqual,
    ">=" => OpCode::GreaterEqual,

    " le " => OpCode::LessEqual,
    "<=" => OpCode::LessEqual,

    " gt " => OpCode::Greater,
    ">" => OpCode::Greater,

    " lt " => OpCode::Less,
    "<" => OpCode::Less,

    "in" => OpCode::In,
};

Op30: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Subtract,
};

Op40: OpCode = {
    "*" => OpCode::Multiply,
    "//" => OpCode::FloorDivide,
    "/" => OpCode::Divide,
};

Op50: OpCode = {
    "%" => OpCode::Modulus,
    "^" => OpCode::Exponent,
};

Number: f64 = {
    r"[0-9]+" => f64::from_str(<>).unwrap(),
    r"[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
    r"\.[0-9]+" => f64::from_str(<>).unwrap(),
};

String: String = {
    <s: r#""([^"\\]*(\\")?)*""#> => s[1..s.len() - 1].to_string().replace("\\\"", "\""),
    <s: r#"'([^'\\]*(\\')?)*'"#> => s[1..s.len() - 1].to_string().replace("\\'", "'"),
};

Identifier: String = {
    r#"[a-zA-Z_][a-zA-Z0-9_]*"# => <>.to_string()
}

Index: Box<Expression> = {
    "[" "." <ident: Identifier> <op: ComparisonOp> <right: Expr90> "]" => Box::new(Expression::Filter {ident, op, right}),
    "[" <Expression> "]",
}


Boolean: bool = {
    "true" => true,
    "True" => true,
    "TRUE" => true,

    "false" => false,
    "False" => false,
    "FALSE" => false,
}

Comma<T>: Vec<T> = {
    <v: (<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Array: Vec<Box<Expression>> = {
    "[" <Comma<Expression>> "]"
}

Object: Vec<(String, Box<Expression>)> = {
    "{" <Comma<(<ObjectIdentifier> ":" <Expression>)>> "}",
    "{}" => vec![],
}

ObjectIdentifier: String = {
    String, 
    Identifier
}
